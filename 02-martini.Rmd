# The *martini* R package {#martini}

From the beginning of my thesis, my work was related to SConES [@azencott_efficient_2013], a GWAS oriented high-score subnetwork search method developed by my supervisor Dr. Chlo√© A. Azencott. SConES works on a SNP network, where SNPs are linked to each other if there is evidence of shared function (e.g. they both are mapped to the same gene). Then, SConES finds a small set of highly interconnected SNPs associated to the disease by solving the following problem:

\begin{equation}
\underset{S \subseteq G}{\arg \max } \underbrace{\sum_{v \in V_S} s_v}_{\text { association }}-\underbrace{\lambda \sum_{v \in V_S} \sum_{u \not\in V_S} W_{vu} }_{\text { connectivity }}-\underbrace{\eta \lvert V_S \rvert }_{\text { sparsity }}
\end{equation}

where $\eta$ and $\lambda$ are hyperparameters, s_v is the association score of node v, and W is the Laplacian matrix. A more detailed description of SConES can be found in [@azencott_efficient_2013] and in the section /Methods used/ of Chapter TODO.   

With the intention of applying SConES to the GENESIS dataset, I started working on a user-friendly version. The result was an R package, /martini/, which is published with Bioconductor 3.7. Bioconductor is a peer-reviewed R repository. /martini/ is based on EasyGWAS' implementation of SConES [@grimm_easygwas_2017]. Hence, it combines the accessibility of R and and the Bioconductor environment with the computational efficiency of C++.

## Improvements
### Association using $\chi^2$ statistic

SConES scores the relevance of each SNP to the phenotype using the SKAT test of association [@ionita-laza_sequence_2013]. We decided to additionally implement the $\chi^2$ statistic, the *de facto* standard measure of association between two qualitative variables. Then, we compare how it behaves in comparison to SKAT to decide which association score works best in our experimental setting.

### Hyperparameter optimization

One of the earliest issues we detected in the implementation of SConES was its inability to find the most appropriate values for the hyperparameters $\lambda$ and $\eta$. After examining simulated examples were SConES was retrieving suboptimal solutions, we implemented the following changes.

#### Selection criterion 

SConES chooses the best set of parameters based on consistency across folds. Each $\lambda$ and $\eta$ is explored in a 10-fold setting. Then, the consistency $C$ between the selection vectors $v_i$ and $v_j$ of two folds is calculated as

$$ C = N \|v_i * v_j \|_0 - \|v_i\| _0\|v_j\|_0 .$$

Then a normalized consistency $C'$ is calculated by dividing by the maximum possible consistency

$$ maxC = N \min(\|v_i\| _0, \|v_j\|_0) - \|v_i\| _0\|v_j\|_0. $$

A mean of all pairwise comparisons is returned as consistency score. Consistency was the choice for SConES as more conventional model selection approaches (e.g. AUC) displayed proneness to overfitting.

We explored alternatives to consistency as selection criterion, specifically information theory-based criteria. These measures are also known as penalized log-likelihood, as they try to maximize

$$L(X,y,\hat{\theta})-c(\hat{\theta})$$

where $\hat{\theta}$ is a vector of parameters (for linear models, this is ($\hat{\beta}, \sigma^{2}$)); $L(X,y,\hat{\theta})$ is the likelihood function of the model; and $c(\hat{\theta})$ is a measurement of model complexity, usually some norm that measures how big $\hat{\theta}$ is [@Dziak2005]. In general, these measurements take this form:

$$L(X,y,\hat{\theta})-\lambda p_{in}$$

where $\lambda$ is a factor that controls the penalty for complexity; and $p_{in}$ is the number of parameters included in the model. We are exploring three measures:

$$ AIC=2L(X,y,\hat{\theta})-2p_{in} $$

$$ BIC = -2L(y|x,\hat{\theta}_{M_i})-ln(n)(p_{in}+ 2) $$

$$ AIC_c=AIC+\frac{2p_{in}(p_{in}+1)}{n-p_{in}-1}=-2L(X,y,\hat{\theta})+2(\dfrac{n}{n-p_{in}-1})p_{in} $$

With the selected SNPs for each $\lambda$ and $\eta$ we build a logistic regression model. We estimate the likelihood of the model and, in consequence, AIC, BIC and AICc.

## Network-based simulations

## Interface, documentation and quality assurance 

Last, but not least, /martini/ includes the two main groups of functions required to run SConES. The first group includes the creation of the SNP networks: /get_GS_network()/ for a network that relates the SNPs based on genomic structure; /get_GM_network()/ for a network that, on top of the previous one, relates SNPs mapped to the same gene; and /get_GI_network()/ which, on top of the latter, relates SNPs mapped to genes that interact in a user provided list. The second important function is /scones()/ which takes a GWAS dataset and a SNP network and runs SConES.

All functions exported by /martini/ have a man page, and hence information of the functions arguments, behavior and return value can be obtained via /help(fun)/. Accompanying examples and toy datasets are provided. Additionally, I wrote two vignettes to explain its basic behavior: one to run SConES (/Running SConES/), and another to simulate network-based phenotypes (/Simulating SConES-based phenotypes/).

/martini/ was thoroughly subject to unit tests via the /testthat/ package [@wickham_testthat:_2011]. At the moment of writing this text, /martini/ had a code coverage of 96%.

## The *scones.nf* pipeline

In addition to the changes implemented in /martini/, I developed a ready to use computational pipeline that simplifies the usage of SConES from just genotype data in PLINK binary files and, when needed, a gene annotation file and a protein-protein interaction file. The pipeline /scones.nf/ is available on GitHub (https://github.com/hclimente/gwas-tools). In terms of function, the difference with vanilla SConES is that it performs an exhaustive grid-search to optimize both $\lambda$ and $\eta$, as opposed to SConES' single grid search. In the latter, both parameters explore the same range of values, which is calculated from the association scores $c$ (e.g. SKAT score). It creates a linearly spaced n-component vector (n = 10 by default) between $\lfloor \log_{10} \min(c) \rfloor$ and $\lceil \log_{10} \max(c) \rceil$, then explores its powers of 10.

In /scones.nf/ we make the grid search finer, because it explores the grid in an iterative way. After the first exploration, the best $\lambda$ and $\eta$ according to some selection criterion are picked. Then, a new hyperparameter space ranging from $\log_{10}(\text{best } \lambda) - \Delta$ to $\log_{10}(\text{best } \lambda) + \Delta$, where $\Delta = 0.2(\log_{10}\max{\lambda_{explored}}- \log_{10} \min{\lambda_{explored}}$. Prior to these improvements, /scones.nf/ was not able, in some instances, to recover the best solution, returning a trivial solution instead.

## Experiments on simulated data

We propose that gin will detect biomarker with increased sensibility respect to non-network frameworks. In other words, gin should be able to detect causal SNPs for less heritable phenotypes. In order to test this hypothesis, we will perform simulations on the GENESIS data where we picked causal, interconnected SNPs, simulate a phenotype in each case, and check how many of them were retrieved by gin. The simulation tool is implemented in /martini/. It was inspired by the \textit{--simu-cc} function of the GCTA suite [@Yang2011].

A random set of 20 interconnected SNPs from the biggest clique of the SNP network will be picked as causal. Then, a qualitative phenotype $y_j$ is simulated for a patient $j$ using the following additive model:

$$ y_j = \sum\nolimits_i w_{ij} u_i + e_j $$

where the weight $w_{ij}$ is the inclination of the genotype $i$ of patient $j$ over the phenotype; the allelic effect of the $i$-th causal variant $u_i$ in arbitrary units; and the residual effect $e_j$ is the the proportion of the trait not attributable to the genotype. 

The weight $w_{ij}$ is calculated as

$$ w_{ij} = \frac{x_{ij} - 2p_i}{\sqrt{2p_i(1 - p_i)}} $$

\begin{figure}
\includegraphics[width = \linewidth]{fig/2_p_vs_w.png}
\caption{Allelic effect $i$ as function of causal allele frequency $p$ for different counts of causal allele in a patient ($x = 0, 1, 2$).}
\label{fig:p_vs_w}
\end{figure}

where $x_{ij}$ is the number of reference alleles for the $i$-th causal variant of the $j$-th individual; and $p_i$ is the frequency of the $i$-th causal variant. $w_{ij}$ follows a sigmoid like behavior for different $p$ (Fig. \ref{fig:p_vs_w}): the rarer an allele is, the stronger its impact on the phenotype.

The most interesting bit of this simulation, however, has to do with the residual effect $e_j$, given that it depends directly on the heritability of the trait. $e_j$ is generated from a normal distribution with mean of 0 and variance 

$$ \frac{1}{h^2 - 1} var(\sum\nolimits_i w_{ij} u_i)$$

When all variance is due to genetics ($h^2 = 1$), $e_j = 0$ for all the patients $j$.