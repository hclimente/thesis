# The *martini* R package {#martini}

Parts of this work were presented in ISMB/ECCB 2017 in the poster *Héctor Climente-González and Chloé-Agathe Azencott*, R package for network-guided Genome-Wide Association Studies.

```{r echo=FALSE, results = "asis", eval='is_latex_output'}
cat("\\begin{chapabstract}{Abstract:}
In this chapter I introduce martini and \\verb|scones.nf|. martini is an implementation of SConES in R with three improvements over previous ones. First, it includes measures of association for binary traits ($\\chi^2$ and logistic regression). Second, it accepts user-specified covariates, included as additional terms in the logistic regression. Third, it includes four ways of scoring the cross-validation folds: consistency (as other implementations), and three penalized log-likelihood measures (BIC, AIC, and AICc). martini is available in Bioconductor 3.7. \\verb|scones.nf| is a computational package that further facilitates the usage of martini. It does so by accepting common file formats for GWAS and networks, and by performing a two-staged cross-validation that achieves better hyperparameters. \\verb|scones.nf| is available on \\url{https://github.com/hclimente/gwas-tools}.
\\end{chapabstract}
\\vskip 0.2in
\\begin{chapabstract}{Résumé :}
Dans ce chapitre, je pr\\'esente martini et \\verb|scones.nf|. martini est 
une impl\\'ementation en R de SConES, qui pr\\'esente trois am\\'eliorations sur 
les impl\\'ementations pr\\'ec\\'edentes. Tout d'abord, martini inclut des 
mesures d'association pour des traits binaires ($\\chi^2$ et r\\'egression 
logistique). Deuxi\\`emement, martini permet de sp\\'ecifier des covariables, 
incorpor\\'ees comme des termes suppl\\'ementaires dans la r\\'egression 
logistique. Troisi\\`emement, martini inclut quatre façons de mesurer la 
performance en validation crois\\'ee : la consistance (comme pr\\'ec\\'edemment), 
et trois mesures de log-vraisemblance p\\'enalis\\'ee (BIC, AIC and AICc). 
martini est disponible dans Bioconductor 3.7. \\verb|scones.nf| est un paquet 
logiciel qui facilite encore plus l'utilisation de martini, en acceptant 
des formats de fichiers usuels pour les donn\\'ees GWAS ainsi que les 
r\\'eseaux, et gr\\^ace \\`a une validation crois\\'ee en deux \\'etapes qui permet 
d'obtenir de meilleurs hyperparam\\`etres. \\verb|scones.nf| est disponible 
sur \\url{https://github.com/hclimente/gwas-tools}.
\\end{chapabstract}")
```

## Introduction

In Chapter \@ref(genesis) I presented six high-score subnetwork search methods, and their application to GWAS. In this chapter I focus on my work on one of them, SConES [@azencott_efficient_2013], which was presented with the other methods in Section \@ref(methods:methods). As a reminder, SConES finds a small set of highly interconnected SNPs associated to the disease by solving the following problem:

\begin{equation}
\underset{S \subseteq G}{\arg \max } \underbrace{\sum_{v \in V_S} s_v}_{\text { association }}-\underbrace{\lambda \sum_{v \in V_S} \sum_{u \not\in V_S} W_{vu} }_{\text { connectivity }}-\underbrace{\eta \lvert V_S \rvert }_{\text { sparsity }},
\end{equation}

where $\lambda$ and $\eta$ are hyperparameters, $s_v$ is the association score of node $v$, and $W$ is the Laplacian matrix of the network. The mathematical notation is described in Section \@ref(methods:notation). SConES works on SNP networks in which the SNPs are linked to each other if there is evidence of shared function, for instance, if they are mapped to the same gene (Section \@ref(intro-interpretability)).

With the goal of applying SConES to the GENESIS dataset (Section \@ref(genesis-dataset)), I developed a user-friendly version that solved some of SConES' initial shortcomings (detailed in Section \@ref(martini-improvements)). The result was an R package, *martini* [@martini], which was published in Bioconductor 3.7 [@bioconductor], a peer-reviewed R repository. *martini* was the R version ("user friendly") of *gin* (GWAS Incorporating Networks), which is my \verb!C++! re-implementation of SConES based, in turn, on EasyGWAS [@grimm_easygwas_2017]. Hence, *martini* combines the accessibility of R and of the Bioconductor environment with the computational efficiency of \verb!C++!.

## Improvements over SConES {#martini-improvements}

### Covariates and additional measures of association

SConES scored the relevance of each SNP to the phenotype using the linear SKAT test of association [@wu_rare-variant_2011;@ionita-laza_sequence_2013]. Yet, no version of SConES implemented a way to measure association with a binary phenotype, like logistic regression-based SKAT. Hence, we decided to implement two additional measures of association in *martini*, $\chi^2$ and logistic regression, to apply SConES on case-control studies. Additionally, the latter allowed *martini* to handle covariates and hence correct for population structure (Section \@ref(pop-structure)).

### Hyperparameter optimization

By examining the results of other implementations of SConES on simulated examples, we observed that it produced suboptimal solutions. Those (unshown) results were either trivial ones (all SNPs or no SNP retrieved), or cases where SNPs strongly associated with a phenotype were not selected. To address those issues, I experimented with altering how SConES chooses its hyperparameters ($\lambda$ and $\eta$), in the hope that other values would produce better solutions.

SConES chooses the best $\lambda$ and $\eta$ based on consistency across 10 cross-validation folds. In other words, for each specific combination of $\lambda$ and $\eta$ to evaluate, the data is divided into 10 equal parts, or folds, each containing 90\% of the samples. In each fold, a selection vector $v$ is produced with the respective hyperparameters. The length of $v$ is equal to the number of SNPs $N$, and each element is set to 0, if the corresponding SNP is not selected, and to 1, if it is. The consistency $C$ between the selection vectors $v_i$ and $v_j$ of two folds for the same $\lambda$ and $\eta$ can be calculated as

$$ C = N\|v_i \cdot v_j \|_0 - \|v_i\| _0\|v_j\|_0 .$$

Then a normalized consistency $C'$ is computed by dividing $C$ by the maximum possible consistency $C^*$:

$$C^* = N \min(\|v_i\| _0, \|v_j\|_0) - \|v_i\| _0\|v_j\|_0. $$

Each combination of $\lambda$ and $\eta$ is scored using the mean of all such pairwise normalized consistencies. The hyperparameters that produce the most consistent result are used on the whole dataset to produce the algorithm's output. Consistency was the metric of choice in the original SConES to favor stability in the solution [@azencott_efficient_2013]. 

We explored alternatives to consistency as selection criterion. Measures based on the accuracy of a linear classifier trained on the selected SNPs had been tested before, but exhibited proneness to overfitting. Hence we turned to penalized log-likelihood measures [@Dziak2005], developed in the field of information theory. These scoring functions had the potential to overcome the overfitting of a linear classifier by adding a regularization term to improve generalization. They take the form

$$L(X,y,\hat{\theta})-c(\hat{\theta}),$$

where $L(X,y,\hat{\theta})$ is the log-likelihood of the model, which depends on the feature matrix $X$, the outcome vector $y$, and the parameters $\hat{\theta}$; and $c(\hat{\theta})$ is a measurement of the model's complexity. Particularly, we explored three measures [@Dziak2005]: Akaike information criterion (AIC), Bayesian information criterion (BIC), and corrected Akaike information criterion (AICc). All three take the form

$$L(X,y,\hat{\theta})-\lambda p_{in},$$

where $\lambda$ is a factor that controls the penalty for complexity; and $p_{in}$ is the number of features included in the model. Specifically they are defined as:

$$ AIC=2L(X,y,\hat{\theta})-2p_{in} ,$$

$$ BIC = -2L(X,y,\hat{\theta})-\ln(n)(p_{in}+ 2) ,$$

and

$$ AIC_c=AIC+\frac{2p_{in}(p_{in}+1)}{n-p_{in}-1}=-2L(X,y,\hat{\theta})+2\left(\dfrac{n}{n-p_{in}-1}\right)p_{in} .$$

AICc is a modification of AIC that penalizes complex models (many features included) in high dimensional settings, that is, where the number of features is much larger than the number of samples, as in GWAS.

*martini* implements these three measures to score each combination of hyperparameters. As with consistency, every considered $\lambda$ and $\eta$ is tested in a 10-fold split of the data. Then, for each fold, a linear model is built, which aims to predict the phenotype using the SNPs selected in that fold. These scores relate the likelihood of these linear models to its complexity. Each combination of hyperparameters is scored by averaging the 10 folds, and the one that produces the lowest score on average is chosen. In some simulation studies (not shown), we observed that they solved the problems of the consistency score outlined above.

### Network-based simulations

We conjecture that SConES will detect biomarker with increased sensibility respect to non-network frameworks. In other words, it should be able to detect causal SNPs for less heritable phenotypes. In order to test this hypothesis, *martini* facilitates the simulation of phenotypes and interconnected causal networks on real GWAS datasets. This simulation tool is broken down into two functions.

The first of them is `simulate_causal_snps()`, which takes a SNP network in which each SNP is annotated with the genes it maps to (as can be obtained by `get_GI_network()`, see Section \@ref(martini-ui)). It takes two additional parameters: the number of genes involved in the disease (`n`), and the proportion of the SNPs mapped to a causal gene that are causal themselves (`p`). Then, it randomly scans the network until it finds a maximum of two connected SNP subnetworks that are mapped to `n` different genes. A fraction `p` of such subnetwork are selected as causal.

The second function is `simulate_phenotype()`, which re-implements the `--simu-cc` phenotype simulation function of the GCTA suite [@Yang2011]. `simulate_phenotype()` requires an existing GWAS experiment (`gwas`), and a set of causal SNPs (`snps`). When the causal SNPs are the output of `simulate_causal_snps()`, it inherits the additional constraint that the causal SNPs are connected in an underlying network. It also accepts other optional parameters which I describe below. Then, it simulates the quantitative phenotype $y_j$ for patient $j$ using the following additive model:

$$ y_j = \sum\nolimits_i w_{ij} u_i + e_j ,$$

where the weight $w_{ij}$ is the inclination of the genotype $i$ of patient $j$ over the phenotype; the allelic effect of the $i$-th causal variant $u_i$ in arbitrary units; and the residual effect $e_j$ is the the proportion of the trait not attributable to the genotype. The vector of effect sizes $u$ can be specified by the user via the `effectSize` parameter. If it is not, by default it is sampled from a standard Normal distribution.

The weight $w_{ij}$ is calculated as

$$ w_{ij} = \frac{x_{ij} - 2p_i}{\sqrt{2p_i(1 - p_i)}} $$

where $x_{ij}$ is the number of reference alleles for the $i$-th causal variant of the $j$-th individual; and $p_i$ is the frequency of the $i$-th causal variant. $w_{ij}$ follows a sigmoid like behavior for different $p$ (Figure \@ref(fig:p-vs-w)): the rarer an allele is, the stronger its impact on the phenotype.

(ref:fig-p-vs-w-caption) Allelic effect $i$ as function of causal allele frequency $p$ for different counts of causal allele in a patient ($x = 0, 1, 2$).

```{r p-vs-w, echo=FALSE, fig.cap='(ref:fig-p-vs-w-caption)'}
knitr::include_graphics('fig/2_p_vs_w.png', dpi = NA)
```

An interesting bit of this simulation is the residual effect $e_j$. It depends directly on the heritability of the trait, which must be given by the user via the `h2` parameter. Then $e_j$ is generated from a Normal distribution with mean of 0 and variance 

$$ \frac{1}{h^2 - 1} \text{var} \left(\sum\nolimits_i w_{ij} u_i\right),$$

where $w$ and $u$ are the weight and effect sizes specified above. When all variance is due to genetics ($h^2 = 1$), $e_j = 0$ for all the patients $j$.

Lastly, a user can request a binary phenotype setting the `qualitative` option to `TRUE`. In this case, the user must also specify three additional parameters: the number of cases (`ncases`), the number of controls (`ncontrols`), and the prevalence of the trait (`prevalence`). With these parameters, `simulate_phenotype()` takes the `ncontrols` samples with the lowest $y$ as controls, and the `ncases` samples with the highest $y$ as cases. However, `ncases` needs to be lower or equal than `prevalence` $\times |y|$, where $|y|$ is the total number of samples in the GWAS experiment. This ensures that only the most extreme samples (as defined by the prevalence and the qualitative simulation) are cases.

### Interface, documentation and quality assurance {#martini-ui}

Last, but not least, *martini* includes the two main groups of functions required to run SConES. The first group involves the creation of the SNP networks, which were described in detail in Section \@ref(methods:snp-network). They are the `get_GS_network()`, to obtain a network that relates the SNPs based on genomic structure; `get_GM_network()` for a network that, on top of the previous one, relates SNPs mapped to the same gene; and `get_GI_network()` which, on top of the latter, relates SNPs mapped to genes that interact in a user provided list. The second important function is `scones()` which takes a GWAS dataset and a SNP network and runs SConES.

All functions exported by *martini* have a `man` page, and hence information of the functions arguments, behavior and return value can be obtained via `help(fun)`. Accompanying examples and toy datasets are provided. Additionally, I wrote two vignettes to explain its basic behavior: one to run SConES ([*Running SConES*](https://www.bioconductor.org/packages/release/bioc/vignettes/martini/inst/doc/scones_usage.html)), and another to simulate network-based phenotypes ([*Simulating SConES-based phenotypes*](https://www.bioconductor.org/packages/release/bioc/vignettes/martini/inst/doc/simulate_phenotype.html)).

*martini* was thoroughly subjected to unit tests via the *testthat* package [@wickham_testthat:_2011]. At the moment of writing this text, *martini* had a code coverage of 96%.

## The `scones.nf` pipeline

In addition to the changes implemented in *martini*, I developed a ready-to-use computational pipeline that simplifies its usage: `scones.nf`. This pipeline just requires genotype data in PLINK binary file format and, when needed for the creation of a GM or GI network, a gene annotation file and a protein-protein interaction file. `scones.nf` is available on GitHub (https://github.com/hclimente/gwas-tools). In terms of function, the difference with vanilla *martini* is that it performs an exhaustive grid-search to optimize both $\lambda$ and $\eta$, as opposed to *martini*'s single grid search step. In the latter, both parameters explore the same range of values, which is calculated from the association scores $c$ (e.g. SKAT score). Specifically, it creates a linearly spaced n-component vector (n = 10 by default) between $\lfloor \log_{10} \min(c) \rfloor$ and $\lceil \log_{10} \max(c) \rceil$, then explores its powers of 10. On the other hand `scones.nf` makes the grid search finer, because it explores the grid in an iterative way. After the first exploration, identical to the one just described, the best $\lambda$ and $\eta$ according to some selection criterion are picked. Then it creates a new hyperparameter space, ranging from $\log_{10}(\text{best } \lambda) - \Delta$ to $\log_{10}(\text{best } \lambda) + \Delta$, where $\Delta = 0.2(\log_{10}\max{(\text{explored }\lambda)}- \log_{10} \min{(\text{explored }\lambda)})$. The final $\lambda$ and $\eta$ are chosen using the same procedure on this new grid. Prior to these improvements, `scones.nf` was not able, in some instances, to recover the best solution, returning a trivial solution instead.

## Conclusions

In this chapter I introduced *martini* and the `scones.nf` pipeline. Jointly, they make SConES easily applicable to any GWAS dataset. Specially, they provide a wider range of options to the user in terms of how to measure the association between the genotypes and the phenotype, and how to select SConES hyper-parameters. Thanks to these improvements, we were able to obtain the SConES results presented in Chapter \@ref(genesis). Additionally, we provide a network-based phenotype simulation framework. *martini* [@martini] is available in Bioconductor (https://www.bioconductor.org/packages/martini); `scones.nf` is available on GitHub (https://github.com/hclimente/gwas-tools).

However, *martini* and SConES still present shortcomings with regards to hyper-parameter selection (Sections \@ref(results-benchmark) and \@ref(genesis-issues)). As we note, SConES solutions were unstable despite using *consistency* for model selection. This requires further examination. Additionally, when applied to GENESIS the selected solutions did not use the protein-protein interaction network, but other methods did. Although this is, to some extent, expected in that dataset, it does not inform much about the biology of the disease. In other words, in this case, SConES should be more tolerant to including unassociated SNPs in order to interconnect subnetworks of strongly associated SNPs. Hence, different parameters (lower values of $\lambda$) might relax the connectivity constraints enough to capture biological mechanisms more broadly. In this regard, it would be promising to use topological measures as scores for hyperparameter selection, for instance favoring settings that lead to densely interconnected networks. In this vein, it also is worth further exploring SigMod [@liu_sigmod:_2017] a modification of SConES described in Section \@ref(methods:methods). While SConES penalizes selecting SNPs with many outbound edges and does not account for inbound edges, SigMod favours SNPs with many inbound edges, while disregarding outbound edges.

Lastly, I would like to explore SNP networks beyond the ones proposed in the original manuscript (Section \@ref(methods:snp-network)). As I described in Section \@ref(intro-interpretability), and will deepen in Chapter \@ref(epi-snp2gene), there are multiple ways of relating SNPs to a function, and hence to build SNP networks. One compelling idea is to build a SNP network that reflects the 3D structure of the genome. Another opportunity for development involves encoding the LD relationship between the SNPs in the network, by tuning the edge weights. This would allow to either favor the selection of LD blocks (large LD implies large edge weight), or favor the selection of independent, associated SNPs (large LD implies small edge weight). These networks are very complex, involving hundreds of thousands of nodes and tens of millions of edges. In this regard, the ability of SConES to efficiently handle such networks enables this research and motivates working on solving the aforementioned issues. 